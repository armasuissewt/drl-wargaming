# dte_simulator.py
#
# Discrete-time event simulator
#
# Author: Giacomo Del Rio
# Creation date: 16 May 2023

from __future__ import annotations

from abc import ABC
from typing import List, Dict, Optional

from numpy.random import default_rng

from simulator.geodesics import geodetic_distance, geodetic_bearing
from simulator.units_of_measure import Latitude, Longitude, Degree, Meters, Seconds


class Pose:
    """ A pose contains information about the placement and orientation of a unit in space """

    def __init__(self, lat: Latitude, lon: Longitude, heading: Degree, altitude: Meters):
        assert -90 <= lat <= 90
        assert 0 <= lon <= 180
        assert 0 <= heading < 360
        assert 0 <= altitude
        self.lat: Latitude = lat
        self.lon: Longitude = lon
        self.head: Degree = heading
        self.alt: Meters = altitude  # [0, inf)

    def copy(self) -> Pose:
        return Pose(self.lat, self.lon, self.head, self.alt)

    def __str__(self):
        return f"Pose({self.lat}, {self.lon}, {self.head}, {self.alt})"


class Unit(ABC):
    """ A Unit is the basic component of the simulation. This is the base abstract class for a generic unit.

        Each unit has a unique positive integer id which is assigned when added to the simulation engine:
        when building a unit, it is set as -1, it will be filled later.
    """

    def __init__(self, pose: Pose):
        self.pose: Pose = pose
        self.id: int = -1

    def update(self, time_elapsed: Seconds, sim: DteSimulator) -> List[Event]:
        """ Update the unit as if tick_secs passed. (E.g. move unit)

        :param time_elapsed: the time elapsed
        :param sim: the simulator object
        :return: a list of Events generated by the update
        """
        raise NotImplementedError()

    def distance_to(self, unit_to: Unit) -> Meters:
        """ Compute the distance between this unit and unit_b

        :param unit_to: the unit to compute the distance to
        :return: the distance in meters
        """
        return geodetic_distance(self.pose.lat, self.pose.lon, unit_to.pose.lat, unit_to.pose.lon)

    def bearing_to(self, unit_to: Unit) -> Degree:
        """ Compute the angle between this unit and unit_b

        :param unit_to: the unit to compute the angle to
        :return: the angele in degrees
        """
        return geodetic_bearing(self.pose.lat, self.pose.lon, unit_to.pose.lat, unit_to.pose.lon)

    def to_string(self) -> str:
        return f"Unit[{self.id}]({self.pose})"


class Event(ABC):
    """ An event can be generated during the update() of a Unit """

    def __init__(self, name: str, origin: Unit):
        self.name = name
        self.origin = origin

    def __str__(self):
        return f"{self.name}[{self.origin.id}]"


class DteSimulator:
    """ The DteSimulator is the main class that implements the simulation loop """

    def __init__(self, tick_time: Seconds, random_seed: Optional[int] = None):
        """ Build a new DteSimulator

        :param tick_time: the elapsed time between one step of simulation to the following, in seconds
        :param random_seed: if provided, uses this random seed
        """
        self.tick_secs: Seconds = tick_time
        self.time_elapsed: Seconds = 0

        self.rnd_gen = default_rng(random_seed)
        self.active_units: Dict[int, Unit] = {}  # id -> Unit
        self._next_unit_id: int = 1

    def add_unit(self, unit: Unit) -> int:
        """ Add a new unit to the simulation

        :param unit: the unit to add (it should not be already added previously)
        :return: the assigned id of the unit
        """
        self.active_units[self._next_unit_id] = unit
        unit.id = self._next_unit_id
        self._next_unit_id += 1
        return unit.id

    def remove_unit(self, unit_id: int) -> None:
        """ Remove a unit from the simulation

        :param unit_id: the id of the unit to be removed
        """
        del self.active_units[unit_id]

    def get_unit(self, unit_id: int) -> Unit:
        """ Get a unit from its id

        :param unit_id: the unit id
        :return: the Unit
        """
        return self.active_units[unit_id]

    def unit_exists(self, unit_id: int) -> bool:
        """ Checks if a Unit exists in the simulation

        :param unit_id: the Unit id
        :return: True if the unit exists in the simulation, False otherwise
        """
        return unit_id in self.active_units

    def do_tick(self) -> List[Event]:
        """ Perform one step of the simulation

        :return: A list of Events generated by the update() calls
        """
        # Update the state of all units
        events: List[Event] = []
        for unit in list(self.active_units.values()):
            event_lst = unit.update(self.tick_secs, self)
            events.extend(event_lst)
        self.time_elapsed += self.tick_secs

        return events
